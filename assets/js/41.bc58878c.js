(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{450:function(a,t,v){"use strict";v.r(t);var _=v(2),r=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"javafunction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javafunction"}},[a._v("#")]),a._v(" JavaFunction")]),a._v(" "),t("h2",{attrs:{id:"方法的类别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法的类别"}},[a._v("#")]),a._v(" 方法的类别")]),a._v(" "),t("p",[a._v("分为成员方法和构造方法，成员方法又分为静态方法和实例方法。")]),a._v(" "),t("h3",{attrs:{id:"方法的定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法的定义"}},[a._v("#")]),a._v(" 方法的定义")]),a._v(" "),t("p",[a._v("位置：在类体中定义方法，专门完成一个功能，除了main方法会被JVM调用之外，其他方法都是只在被调用时执行。\n语法：修饰符列表 返回值类型 方法名 (形参列表){方法体}")]),a._v(" "),t("p",[a._v("注意：")]),a._v(" "),t("ul",[t("li",[a._v("构造方法没有返回值类型。")]),a._v(" "),t("li",[a._v("抽象方法没有方法体。")]),a._v(" "),t("li",[a._v("在返回值不是void类型时，都需要用return语句返回相应语句，返回语句必须要执行，执行后方法必结束。")])]),a._v(" "),t("h3",{attrs:{id:"方法的参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法的参数"}},[a._v("#")]),a._v(" 方法的参数")]),a._v(" "),t("p",[a._v("参数可以是基本数据类型，引用数据类，实参与形参数量，类型，顺序都必须相同")]),a._v(" "),t("h3",{attrs:{id:"方法体"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法体"}},[a._v("#")]),a._v(" 方法体")]),a._v(" "),t("p",[a._v("由Java语句组成，数据来源是形参，\n里面的变量为局部变量，方法一结束，变量就内存释放。")]),a._v(" "),t("h3",{attrs:{id:"方法的返回值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法的返回值"}},[a._v("#")]),a._v(" 方法的返回值")]),a._v(" "),t("p",[a._v("只能返回特定类型的值，只能返回一个值。")]),a._v(" "),t("h3",{attrs:{id:"方法体的执行顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法体的执行顺序"}},[a._v("#")]),a._v(" 方法体的执行顺序")]),a._v(" "),t("p",[a._v("自上而下顺序执行，main最先执行，最后结束")]),a._v(" "),t("h2",{attrs:{id:"方法的调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法的调用"}},[a._v("#")]),a._v(" 方法的调用")]),a._v(" "),t("p",[a._v("静态方法：使用 ‘’类名.方法名‘’ 的方式调用，当静态方法是在本类时，可以不写类名。\n实例方法：使用==对象引用.方法名==的方式调用，当引用为null时调用会出现空指针异常。\n可以用变量(局部/实例)来储存返回值，类型必须相当。")]),a._v(" "),t("p",[a._v("返回值类型如果不是void时，必须百分之百执行return语句，所以在条件语句(if.switch)后的==return==可能不执行的话,编译器将报错。带有else分支的可以保证一定执行return语句，或在if语句块后加上return语句，另外，如果return语句后的语句不能执行，也会报错。")]),a._v(" "),t("h3",{attrs:{id:"方法递归"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法递归"}},[a._v("#")]),a._v(" 方法递归")]),a._v(" "),t("p",[a._v("方法递归是方法自身调用自身，特点")]),a._v(" "),t("ul",[t("li",[a._v("需要结束条件，若无结束条件，则会导致栈内存溢出")]),a._v(" "),t("li",[a._v("即使有结束条件也可能会出现栈内存溢出，因为可能栈内存不够。")]),a._v(" "),t("li",[a._v("尽量使用循环来代替递归，耗费内存少，效率高，递归耗费的内存大，效率低(即调用方法比循环时间大)，少数情况需要递归来实现功能。")])]),a._v(" "),t("p",[a._v("图示：")]),a._v(" "),t("h2",{attrs:{id:"方法重载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法重载"}},[a._v("#")]),a._v(" 方法重载")]),a._v(" "),t("p",[a._v("Java编译器在==同一个类中==区分方法，是以==方法名区分==，当名字相同时，以==参数区分==。而名称相同，参数不同的方法之间，就构成了方法重载。")]),a._v(" "),t("p",[a._v("方法重载的特点:")]),a._v(" "),t("ol",[t("li",[a._v("同一类中")]),a._v(" "),t("li",[a._v("方法名相同")]),a._v(" "),t("li",[a._v("参数不同(数量，类型，顺序)\n注意：与方法返回值无关\n作用：代码简化")])]),a._v(" "),t("h2",{attrs:{id:"jvm简单内存模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm简单内存模型"}},[a._v("#")]),a._v(" JVM简单内存模型")]),a._v(" "),t("ul",[t("li",[a._v("栈：执行方法的地方，先进后出，所以main方法最先执行，最后结束，调用方法即入栈，方法结束即出栈，栈中存储的是方法在运行时需要的内存，局部变量，每个局部变量内存空间各不相同，所以各局部变量的名称相同也可以，他们之间为不同变量。")]),a._v(" "),t("li",[a._v("方法区：存放代码片段的地方。")]),a._v(" "),t("li",[a._v("堆：对象存储的地方，实例属性都在此存储，")])])])}),[],!1,null,null,null);t.default=r.exports}}]);