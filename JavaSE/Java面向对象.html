<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>封装 | ...</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="...">
    
    <link rel="preload" href="/hive/assets/css/0.styles.68c1324d.css" as="style"><link rel="preload" href="/hive/assets/js/app.222ec454.js" as="script"><link rel="preload" href="/hive/assets/js/7.1224f65b.js" as="script"><link rel="preload" href="/hive/assets/js/2.9fbd6685.js" as="script"><link rel="preload" href="/hive/assets/js/1.77f24ecd.js" as="script"><link rel="preload" href="/hive/assets/js/44.8b524a39.js" as="script"><link rel="prefetch" href="/hive/assets/js/10.dfb0299a.js"><link rel="prefetch" href="/hive/assets/js/11.479e3941.js"><link rel="prefetch" href="/hive/assets/js/14.65104886.js"><link rel="prefetch" href="/hive/assets/js/15.0fe19f29.js"><link rel="prefetch" href="/hive/assets/js/16.3a98beb2.js"><link rel="prefetch" href="/hive/assets/js/17.85dc844f.js"><link rel="prefetch" href="/hive/assets/js/18.060d220d.js"><link rel="prefetch" href="/hive/assets/js/19.77ed2e0b.js"><link rel="prefetch" href="/hive/assets/js/20.1faabea6.js"><link rel="prefetch" href="/hive/assets/js/21.4913a81b.js"><link rel="prefetch" href="/hive/assets/js/22.ec2bffa8.js"><link rel="prefetch" href="/hive/assets/js/23.77700c61.js"><link rel="prefetch" href="/hive/assets/js/24.6badfe0e.js"><link rel="prefetch" href="/hive/assets/js/25.bda1b3e1.js"><link rel="prefetch" href="/hive/assets/js/26.06377f0d.js"><link rel="prefetch" href="/hive/assets/js/27.86112ea9.js"><link rel="prefetch" href="/hive/assets/js/28.be8ca15b.js"><link rel="prefetch" href="/hive/assets/js/29.98f0eb72.js"><link rel="prefetch" href="/hive/assets/js/3.50c72d76.js"><link rel="prefetch" href="/hive/assets/js/30.4c7947d3.js"><link rel="prefetch" href="/hive/assets/js/31.aa1f8d83.js"><link rel="prefetch" href="/hive/assets/js/32.bac8f00d.js"><link rel="prefetch" href="/hive/assets/js/33.cb9d2429.js"><link rel="prefetch" href="/hive/assets/js/34.380ce34c.js"><link rel="prefetch" href="/hive/assets/js/35.b5fcd8bd.js"><link rel="prefetch" href="/hive/assets/js/36.34421d06.js"><link rel="prefetch" href="/hive/assets/js/37.974c194a.js"><link rel="prefetch" href="/hive/assets/js/38.d58c99d2.js"><link rel="prefetch" href="/hive/assets/js/39.ada6baa9.js"><link rel="prefetch" href="/hive/assets/js/4.ab7c6b55.js"><link rel="prefetch" href="/hive/assets/js/40.9424520f.js"><link rel="prefetch" href="/hive/assets/js/41.bc58878c.js"><link rel="prefetch" href="/hive/assets/js/42.d9d21d61.js"><link rel="prefetch" href="/hive/assets/js/43.0dfbfe97.js"><link rel="prefetch" href="/hive/assets/js/45.f247a784.js"><link rel="prefetch" href="/hive/assets/js/46.51a252d0.js"><link rel="prefetch" href="/hive/assets/js/47.a6c831b5.js"><link rel="prefetch" href="/hive/assets/js/48.945f66a8.js"><link rel="prefetch" href="/hive/assets/js/49.7076f69c.js"><link rel="prefetch" href="/hive/assets/js/5.8a3b91a7.js"><link rel="prefetch" href="/hive/assets/js/50.6b9d34be.js"><link rel="prefetch" href="/hive/assets/js/6.2727d8db.js"><link rel="prefetch" href="/hive/assets/js/8.617b6635.js"><link rel="prefetch" href="/hive/assets/js/9.cf1faa69.js"><link rel="prefetch" href="/hive/assets/js/vendors~docsearch.c040f9c6.js">
    <link rel="stylesheet" href="/hive/assets/css/0.styles.68c1324d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>...</h3> <p class="description" data-v-59e6cb88>...</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/hive/" class="home-link router-link-active"><!----> <span class="site-name">...</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/hive/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      hive
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hive/JavaSE/.html" class="nav-link"><i class="undefined"></i>
  Github
</a></li><li class="dropdown-item"><!----> <a href="/hive/JavaSE/.html" class="nav-link"><i class="undefined"></i>
  掘金
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>9</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/hive/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      hive
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/hive/JavaSE/.html" class="nav-link"><i class="undefined"></i>
  Github
</a></li><li class="dropdown-item"><!----> <a href="/hive/JavaSE/.html" class="nav-link"><i class="undefined"></i>
  掘金
</a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/hive/" class="sidebar-heading clickable router-link-active open"><span>开始首页</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/hive/" aria-current="page" class="sidebar-link">readme</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">封装</h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h2 id="封装"><a href="#封装" class="header-anchor">#</a> 封装</h2> <ul><li>不在对外暴露复杂的数据，封装起来，对外只提供简单的操作入口，优点：数据安全，调用方便，外部不能随意访问，</li></ul> <h3 id="如何封装"><a href="#如何封装" class="header-anchor">#</a> 如何封装</h3> <ul><li>属性私有化,对实例变量添private修饰符</li> <li>一个属性对应setter和getter方法，外部只能通过这两个方法来访问属性值，在方法体中还可以设定if语句来判定输入的数据是否合法。</li></ul> <h3 id="getter-setter方法"><a href="#getter-setter方法" class="header-anchor">#</a> getter/setter方法</h3> <ul><li>getter方法：public 返回值类型 get+ 属性名首字母大写(无参) {return xxx;}</li> <li>setter方法：public 返回值类型 set+属性名首字母大写(1个参数) {xxx = 参数;}。get/set方法必须是实例方法，不能是静态方法。</li></ul> <h2 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h2> <ul><li>子类继承父类，将父类的非私有属性和方法继承给子类，实现代码复用。</li> <li>被继承的类叫父类，继承者为子类，Java中只能单继承</li> <li>Java中有间接继承的效果，A类继承B类，B类继承C类，则A类间接继承C类</li> <li>子类继承父类，除了构造方法之外其他的都可以继承，但是在父类(private)私有的属性和方法在子类不能直接访问,可以通过间接方式来访问。用父类的getter获得父类的私有属性</li> <li>Java中的类假若没有明示的继承任何类，则该类默认继承Object类，Object类是Java语言提供的所有类的根类，也就是说一个对象一开始就有Object类的所有特征，</li> <li>通过子类对象调用继承过来的方法：可以使用。因为子类继承了父类的方法，那方法就属于子类自己的了。语法：子类引用.父类方法</li></ul> <h3 id="继承存在的缺点"><a href="#继承存在的缺点" class="header-anchor">#</a> 继承存在的缺点</h3> <ul><li>父类和子类的耦合度会更高，父类修改，影响子类。</li></ul> <h3 id="什么时候使用继承"><a href="#什么时候使用继承" class="header-anchor">#</a> 什么时候使用继承</h3> <ul><li>凡是能采用“is a ”来描述的， 就可以使用继承。</li></ul> <h3 id="println方法的解释"><a href="#println方法的解释" class="header-anchor">#</a> println方法的解释</h3> <ul><li><p>println方法的解释：System.out.println(&quot;Hello World!&quot;);中Sytem是类名，out后没有括号说明是静态变量，且是一个引用类型静态变量。System.out返回一个对象，然后采用“对象.”的方式prinl调用n()方法。例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
       <span class="token comment">//静态变量</span>
       <span class="token keyword">static</span> <span class="token class-name">Student</span> stu  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> main <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token class-name">Test</span><span class="token punctuation">.</span>stu<span class="token punctuation">.</span><span class="token function">exam</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token comment">//Test.stu表示Student对象</span>
           <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
       <span class="token comment">//实例方法</span>
       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exam</span><span class="token punctuation">(</span><span class="token class-name">String</span> content<span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre></div><ul><li>当println()直接输出引用时，会自动调用引用对象的toString()方法。</li></ul></li></ul> <h2 id="this"><a href="#this" class="header-anchor">#</a> this</h2> <ul><li>this是一个变量，一个引用，每一个对象对应一个this，this保存当前对象的内存地址，执行自身，this代表“当前对象”，this存储在堆内存地址对象的内部。</li></ul> <h3 id="this的应用"><a href="#this的应用" class="header-anchor">#</a> this的应用</h3> <ul><li>this只能使用在实例方法或构造方法地址，哪个引用调用了这个实例或构造方法，则this就是哪个引用，</li> <li>this是可以省略的，省略的话还是默认访问当前对象的属性或方法。</li> <li>在实例方法/构造方法，如果实例变量和局部变量一样名称，则为了区分局部变量和实例变量,“this.”是不能省略的。</li> <li>this可以使用在构造方法中，如果通过当前的构造方法去调用本类的其他构造方法，可以使用以下语法格式：this(实际参数列表);，这个语法作用是代码复用，此语法，该调用语句必须写在构造方法的第一行。</li> <li>注意：this不能出现在静态方法中，因为静态方法不需要new对象既可以调用。没有对象自然没有this。</li></ul> <h2 id="方法重写"><a href="#方法重写" class="header-anchor">#</a> 方法重写</h2> <ul><li><p>定义：(Override):继承了父类的子类中，有些方法可能不需要改进，而有些方法需要改进以满足子类的特定需求，这时就要用方法覆盖来改进子类方法。</p></li> <li><p>满足什么条件时用方法覆盖？</p></li> <li><p>当子类对父类继承过来的方法进行“方法覆盖’后，子类对象再调用该方法时，一定执行覆盖后的方法，那代码怎么写的时候构成了方法覆盖？</p> <ol><li>两个类必须是继承关系</li> <li>重写后的方法和之前的方法具有：相同的(返回值类型、形参列表、方法名称)。</li> <li>访问权限不能更低，可以更高。</li> <li>重写之后的方法不能抛出比原先方法抛出更多的异常。但可以更少。</li> <li>注意：方法覆盖只是针对方法，和属性无关。私有方法无法覆盖，静态方法无法覆盖。</li></ol></li> <li><p>方法重载与方法重写区别：方法重载发生在同一个类中，方法重写发生在具有继承关系的父子类之间。</p></li></ul> <h3 id="重写object类中的tostring方法"><a href="#重写object类中的tostring方法" class="header-anchor">#</a> 重写Object类中的toString方法</h3> <ol><li><p>将Java对象转换成“字符串”</p></li> <li><p>Object类中toString方法的默认形式是：public String toString(){</p> <p>return getClass().getName() + &quot;@&quot;+Integer.toHexString(hashCode());</p> <p>}</p></li></ol> <h2 id="多态机制"><a href="#多态机制" class="header-anchor">#</a> 多态机制</h2> <ol><li>什么是多态？1.多态同一个行为在不同的对象上具有多态不同的表现形式或形态的能力， 2.多态就是一个接口，使用不同实例而指向不同操作</li> <li>体现在父类引用指向子类对象，而父类引用调用父子类共有的方法时，直接调用子类重写后的方法(若重写了)。</li> <li>语法格式：父类类名 变量1 = new 子类构造方法</li></ol> <h3 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="header-anchor">#</a> 向上转型和向下转型</h3> <ul><li><p>向上转型：父类型的引用允许指向子类对象。</p></li> <li><p>向上转型：多态本身就是向上转型过的过程</p> <ul><li>使用格式：父类类型 变量名=new 子类类型();</li> <li>适用场景：当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作。</li></ul></li> <li><p>向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用类型转为子类引用各类型，只有引用需要访问子类特有的方法时才必须要向下转型。</p> <ul><li>使用格式：子类类名 引用2 = (子类类名)引用1</li> <li>适用场景：当要使用子类特有功能时。</li></ul></li> <li><p>instanceof关键字：</p> <ul><li>作用：instanceof可以在运行阶段动态判断某个对象的引用是否属于某种数据类型。</li> <li>Instancof返回值为boolean类型</li> <li>如果要转换的引用所指的对象与被转换的对象类型之间没有继承关系，则会出现ClassCastException异常，</li> <li>语法：if(引用 Instanceof 类型)</li></ul></li></ul> <h3 id="多态示例"><a href="#多态示例" class="header-anchor">#</a> 多态示例</h3> <ul><li><p>实现多态机制的两种方式：</p> <ul><li>父类引用作为方法形参实现多态</li> <li>方法返回值为父类类型实现多态</li></ul></li></ul> <h2 id="构造代码块的特点"><a href="#构造代码块的特点" class="header-anchor">#</a> 构造代码块的特点</h2> <ul><li>语法：{Java语句}，声明在类体中，方法区外。</li> <li>在类加载时不执行，在构造方法调用时执行，构造方法调用一次，构造代码块执行一次。</li> <li>普通代码块都是方法/循环/if...后面的代码块，当方法调用时会执行普通代码块</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>普通代码块<span class="token punctuation">}</span>
</code></pre></div><h2 id="同步代码块的语法"><a href="#同步代码块的语法" class="header-anchor">#</a> 同步代码块的语法</h2> <p>synchronized（被同步对象）{}包裹起来的代码块，</p> <h2 id="同步代码块的作用"><a href="#同步代码块的作用" class="header-anchor">#</a> 同步代码块的作用</h2> <p>在多线程环境下，对共享数据的读写操作是需要互斥进行的，<br>
否则会导致数据的不一致性。同步代码块需要写在方法中。<br>
它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。<br>
示例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
  <span class="token keyword">synchronized</span>（同步对象）<span class="token punctuation">{</span><span class="token comment">//同步代码块  </span>
  <span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre></div><h2 id="静态代码块的特点"><a href="#静态代码块的特点" class="header-anchor">#</a> 静态代码块的特点</h2> <ul><li>语法：static{java语句}，声明在类体中，方法体外。</li> <li>静态代码块在类加载时执行，先于mian方法执行，并且执行一次，自上而下顺序执行</li> <li>一个类中可以编写多个静态代码块</li></ul> <h2 id="什么是构造方法"><a href="#什么是构造方法" class="header-anchor">#</a> 什么是构造方法</h2> <ul><li>可以完成对象创建的方法，以及完成对成员变量的初始化(在构造方法体内实现 this关键字的作用)。</li> <li>当一个类没有提供任何构造方法，系统会默认提供无参构造方法，而这个构造方法被称为缺省构造器，当一个类编写了一个构造方法，系统将不再提供无参构造方法(<font color="#3ddfda">通常也要手动写出无参构造方法</font>)。</li> <li>编写： [修饰符列表] 构造方法名(形式参数列表) {构造方法体}</li></ul> <h2 id="构造方法的特点"><a href="#构造方法的特点" class="header-anchor">#</a> 构造方法的特点</h2> <ul><li><font color="#3ddfda">构造方法不需要指定返回值类型。</font></li> <li>构造方法同样可以重载，参数不同(类型，数量，顺序)</li> <li>修饰符列表写成:public</li> <li>构造方法名必须与类名一致，</li></ul> <h3 id="构造方法的用法"><a href="#构造方法的用法" class="header-anchor">#</a> 构造方法的用法</h3> <ul><li>使用new运算符调用构造方法，new Student(形式参数);</li></ul> <h3 id="构造方法的用处"><a href="#构造方法的用处" class="header-anchor">#</a> 构造方法的用处</h3> <ul><li>实例变量的默认赋值是在调用构造方法创建对象，执行方法体时赋值的，不是在类加载时。而静态变量的默认赋值是在类加载时，局部变量，在执行方法体时。</li></ul> <h2 id="类和对象的概念"><a href="#类和对象的概念" class="header-anchor">#</a> 类和对象的概念</h2> <ul><li>类：抽象的概念，模板。例如“菜”，类中描述的是所有对象的“共同特征信息”。</li> <li>对象：实际存在的个体，也叫实例。例如“西红柿”</li> <li>通过类可以创建对象实例，这个过程叫做实例化。</li> <li>类 = 属性 + 方法，属性对应状态，方法对应动作。</li></ul> <h2 id="对象的创建"><a href="#对象的创建" class="header-anchor">#</a> 对象的创建</h2> <ul><li><font color="#3ddfda">new类名(形参列表)</font>; 通过一个类可以创建N多个对象，new运算符专门负责对象的创建</li> <li>类名 变量名(引用) = new 构造方法名(参数列表);例：Student  s = Student();，此变量可以“充当”存储了对象的内存地址的变量，叫做引用。</li> <li>所有的类都是引用数据类型，类名同时也是引用数据类型名。</li></ul> <h2 id="对象和引用类型变量-引用-的区别"><a href="#对象和引用类型变量-引用-的区别" class="header-anchor">#</a> 对象和引用类型变量(引用)的区别</h2> <ul><li>引用不是对象，创建出来的对象将“内存地址”赋给了引用，引用在方法体内定义,存储在栈内存，<font color="#3ddfda">因此为局部变量，存储着对象的&quot;内存地址&quot;</font>.</li> <li>而new 类名()才是创建出来的对象,创建的对象存=储=在堆内存中。</li></ul> <h2 id="对象对应的jvm内存结构"><a href="#对象对应的jvm内存结构" class="header-anchor">#</a> 对象对应的JVM内存结构</h2> <ul><li><p>创建的对象存储在堆内存中，<font color="#3ddfda">实例变量</font>也存储在堆内存中。</p></li> <li><p>对于实例变量来说没有手动给其赋值，系统将默认赋值，引用数据类型，默认值为null，表示不指向任何对象。</p></li> <li><p>每一个对象都有不同的内存空间，实例变量在访问时必须创建对象，其对应的是不同对象的属性</p> <p>图示</p> <p>![[引用参数传递.jpg]]</p></li></ul> <h2 id="空指针异常"><a href="#空指针异常" class="header-anchor">#</a> 空指针异常</h2> <ul><li>NullPointerExxepetion：Java中规定堆内存的对象应该通过<font color="#3ddfda">引用</font>来间接访问。引用被赋值为==null==后，之前所创建的对象就没有引用指向它了，也就无法访问这个对象，该对象变为垃圾对象。</li> <li>Java中的垃圾回收器GC主要针对回收的是堆内存中的垃圾数据，当没有任何引用指向该对象时，将会被释放回收。</li></ul> <h2 id="对象中属性和方法的调用"><a href="#对象中属性和方法的调用" class="header-anchor">#</a> 对象中属性和方法的调用</h2> <ul><li>方法调用时参数传递：参数传递时，和类型无关，无论时基本数据类型还是引用数据类型，都是将数据值复制一份传递给形参。</li> <li>不能通过类名来直接访问实例变量，应通过对象引用来访问。引用.实例变量名。</li></ul> <h2 id="static修饰后的特点"><a href="#static修饰后的特点" class="header-anchor">#</a> static修饰后的特点</h2> <ul><li><p>所有被static修饰的都是类相关的，类级别的，在类加载时执行。 ^ec7963</p></li> <li><p>所有static修饰的，都采用类名.的方式访问，不用new对象，包括静态变量，静态方法。</p></li> <li><p>变量的分类：</p> <ol><li>根据变量声明的位置，进行划分：在方法体内声明的为局部变量，在类体声明的变量为成员变量。</li> <li>成员变量又可以分为实例变量，静态变量</li></ol></li></ul> <h2 id="静态变量"><a href="#静态变量" class="header-anchor">#</a> 静态变量</h2> <h3 id="存储在哪"><a href="#存储在哪" class="header-anchor">#</a> 存储在哪？</h3> <ul><li>静态变量在类加载时初始化，不需要new对象，静态变量存储在方法区，当这个类型的所有对象的某个属性值都一样时，建议将其定义为静态变量，节省空间。</li></ul> <h2 id="静态方法"><a href="#静态方法" class="header-anchor">#</a> 静态方法</h2> <ul><li><p>什么时候方法定义为静态的？</p> <p>方法都是描述了一个行为，如果该行为必须要有对象去触发，则要用实例方法，如果是编写一个工具类的话，类中的方法一般都是静态的，静态方法的优点是：不需要创建对象就可调用。</p></li></ul> <h2 id="抽象类的定义"><a href="#抽象类的定义" class="header-anchor">#</a> 抽象类的定义</h2> <ul><li>在类名前加上abstract关键字后，该类变为抽象类。</li></ul> <h2 id="抽象类的特点"><a href="#抽象类的特点" class="header-anchor">#</a> 抽象类的特点</h2> <ul><li>类的特点：抽象类不能实例化，需要示例化时，需要用普通类继承抽象类，并实现其中的抽象方法，然后，依靠子类采用向上转型的方式处理；</li> <li>方法的特点：可以有构造方法但不是用来自己创建对象的，而是为了子类构造方法调用的；可以有普通方法，可以有抽象方法。</li> <li>抽象类不能被final和private关键字修饰，因为修饰后抽象类不能被继承了。</li></ul> <h2 id="抽象方法的特点"><a href="#抽象方法的特点" class="header-anchor">#</a> 抽象方法的特点</h2> <ul><li><p>无方法体，由;结尾，在抽象类调用构造方法时必须重写该方法，或者</p> <p>被子类继承后重写。</p></li> <li><p>抽象方法必须为public或者protected（因为如果为private，<br>
则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；</p></li></ul> <h2 id="被子类继承后的抽象方法"><a href="#被子类继承后的抽象方法" class="header-anchor">#</a> 被子类继承后的抽象方法</h2> <ul><li>子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（<br>
如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）；</li></ul> <h2 id="什么是接口"><a href="#什么是接口" class="header-anchor">#</a> 什么是接口</h2> <ul><li>一种引用数据类型，由interface关键字修饰，编译后为.class文件。</li> <li>定义：修饰符 interface 名称{}</li></ul> <h2 id="接口内的内容"><a href="#接口内的内容" class="header-anchor">#</a> 接口内的内容？</h2> <ul><li>只包含两方面内容：常量、抽象方法</li> <li>常量、抽象方法 都是默认public修饰的，且不用final或abstract修饰</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">Mue</span><span class="token punctuation">{</span>
	<span class="token comment">//可以不用final abstract修饰属性和方法，</span>
	<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//常量需赋初值</span>
	<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//抽象方法没有方法体</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="接口的使用"><a href="#接口的使用" class="header-anchor">#</a> 接口的使用？</h2> <ul><li>支持多实现，一个类可以实现多个接口，非抽象类对于实现了的接口必须实现里面所有的抽象方法，且方法都要用public 修饰，因为重写的方法访问权限应该更高，不能更低,实现用implements关键字</li> <li>实现多态</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">Mue</span><span class="token punctuation">{</span>
	<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
<span class="token keyword">class</span> <span class="token class-name">Mud</span> <span class="token keyword">implements</span> <span class="token class-name">Mue</span><span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Mus</span><span class="token punctuation">{</span>
	<span class="token class-name">Mue</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mud</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//多态</span>
	m<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="什么是enum类型"><a href="#什么是enum类型" class="header-anchor">#</a> 什么是Enum类型</h2> <ul><li>Enum(枚举)是一种引用数据类型，编译也生成.class文件</li> <li>语法：enum 枚举类型名{<br>
枚举值1，枚举值2<br>
}</li> <li>枚举中的值可以看作是一个常量，</li> <li>可以列举出来的，才建议使用枚举类型，等于2种类型的建议使用boolean类型，多于2种用枚举类型</li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#封装" class="sidebar-link reco-side-封装" data-v-b57cc07c>封装</a></li><li class="level-3" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#如何封装" class="sidebar-link reco-side-如何封装" data-v-b57cc07c>如何封装</a></li><li class="level-3" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#getter-setter方法" class="sidebar-link reco-side-getter-setter方法" data-v-b57cc07c>getter/setter方法</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#继承" class="sidebar-link reco-side-继承" data-v-b57cc07c>继承</a></li><li class="level-3" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#继承存在的缺点" class="sidebar-link reco-side-继承存在的缺点" data-v-b57cc07c>继承存在的缺点</a></li><li class="level-3" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#什么时候使用继承" class="sidebar-link reco-side-什么时候使用继承" data-v-b57cc07c>什么时候使用继承</a></li><li class="level-3" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#println方法的解释" class="sidebar-link reco-side-println方法的解释" data-v-b57cc07c>println方法的解释</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#this" class="sidebar-link reco-side-this" data-v-b57cc07c>this</a></li><li class="level-3" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#this的应用" class="sidebar-link reco-side-this的应用" data-v-b57cc07c>this的应用</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#方法重写" class="sidebar-link reco-side-方法重写" data-v-b57cc07c>方法重写</a></li><li class="level-3" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#重写object类中的tostring方法" class="sidebar-link reco-side-重写object类中的tostring方法" data-v-b57cc07c>重写Object类中的toString方法</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#多态机制" class="sidebar-link reco-side-多态机制" data-v-b57cc07c>多态机制</a></li><li class="level-3" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#向上转型和向下转型" class="sidebar-link reco-side-向上转型和向下转型" data-v-b57cc07c>向上转型和向下转型</a></li><li class="level-3" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#多态示例" class="sidebar-link reco-side-多态示例" data-v-b57cc07c>多态示例</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#构造代码块的特点" class="sidebar-link reco-side-构造代码块的特点" data-v-b57cc07c>构造代码块的特点</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#同步代码块的语法" class="sidebar-link reco-side-同步代码块的语法" data-v-b57cc07c>同步代码块的语法</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#同步代码块的作用" class="sidebar-link reco-side-同步代码块的作用" data-v-b57cc07c>同步代码块的作用</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#静态代码块的特点" class="sidebar-link reco-side-静态代码块的特点" data-v-b57cc07c>静态代码块的特点</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#什么是构造方法" class="sidebar-link reco-side-什么是构造方法" data-v-b57cc07c>什么是构造方法</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#构造方法的特点" class="sidebar-link reco-side-构造方法的特点" data-v-b57cc07c>构造方法的特点</a></li><li class="level-3" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#构造方法的用法" class="sidebar-link reco-side-构造方法的用法" data-v-b57cc07c>构造方法的用法</a></li><li class="level-3" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#构造方法的用处" class="sidebar-link reco-side-构造方法的用处" data-v-b57cc07c>构造方法的用处</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#类和对象的概念" class="sidebar-link reco-side-类和对象的概念" data-v-b57cc07c>类和对象的概念</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#对象的创建" class="sidebar-link reco-side-对象的创建" data-v-b57cc07c>对象的创建</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#对象和引用类型变量-引用-的区别" class="sidebar-link reco-side-对象和引用类型变量-引用-的区别" data-v-b57cc07c>对象和引用类型变量(引用)的区别</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#对象对应的jvm内存结构" class="sidebar-link reco-side-对象对应的jvm内存结构" data-v-b57cc07c>对象对应的JVM内存结构</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#空指针异常" class="sidebar-link reco-side-空指针异常" data-v-b57cc07c>空指针异常</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#对象中属性和方法的调用" class="sidebar-link reco-side-对象中属性和方法的调用" data-v-b57cc07c>对象中属性和方法的调用</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#static修饰后的特点" class="sidebar-link reco-side-static修饰后的特点" data-v-b57cc07c>static修饰后的特点</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#静态变量" class="sidebar-link reco-side-静态变量" data-v-b57cc07c>静态变量</a></li><li class="level-3" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#存储在哪" class="sidebar-link reco-side-存储在哪" data-v-b57cc07c>存储在哪？</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#静态方法" class="sidebar-link reco-side-静态方法" data-v-b57cc07c>静态方法</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#抽象类的定义" class="sidebar-link reco-side-抽象类的定义" data-v-b57cc07c>抽象类的定义</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#抽象类的特点" class="sidebar-link reco-side-抽象类的特点" data-v-b57cc07c>抽象类的特点</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#抽象方法的特点" class="sidebar-link reco-side-抽象方法的特点" data-v-b57cc07c>抽象方法的特点</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#被子类继承后的抽象方法" class="sidebar-link reco-side-被子类继承后的抽象方法" data-v-b57cc07c>被子类继承后的抽象方法</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#什么是接口" class="sidebar-link reco-side-什么是接口" data-v-b57cc07c>什么是接口</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#接口内的内容" class="sidebar-link reco-side-接口内的内容" data-v-b57cc07c>接口内的内容？</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#接口的使用" class="sidebar-link reco-side-接口的使用" data-v-b57cc07c>接口的使用？</a></li><li class="level-2" data-v-b57cc07c><a href="/hive/JavaSE/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html#什么是enum类型" class="sidebar-link reco-side-什么是enum类型" data-v-b57cc07c>什么是Enum类型</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/hive/assets/js/app.222ec454.js" defer></script><script src="/hive/assets/js/7.1224f65b.js" defer></script><script src="/hive/assets/js/2.9fbd6685.js" defer></script><script src="/hive/assets/js/1.77f24ecd.js" defer></script><script src="/hive/assets/js/44.8b524a39.js" defer></script>
  </body>
</html>
